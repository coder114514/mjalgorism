原文：[https://web.archive.org/web/20241207213017/hp.vector.co.jp/authors/VA046927/mjscore/mjalgorism.html](https://web.archive.org/web/20241207213017/hp.vector.co.jp/authors/VA046927/mjscore/mjalgorism.html)

以下是 markdown 版的 mjalgorism-translated.html

麻将 胡牌判定（役种判定）算法
===============

最后更新日期：2008/4/9

本文说明如何高效判定麻将的胡牌。

通常使用回溯法进行胡牌判定，但回溯法需要穷举所有可能的牌组组合，因此存在处理时间较长的问题 单次执行时处理时间可能不成问题，但在需要反复判定的场景（如AI决策）中，对处理速度有较高要求。本文介绍一种利用索引实现高速判定的方法。

首先说明常规方法，再介绍基于索引的优化方法。


常规方法（回溯法）
---------

若手牌可拆分为１个将头（雀头）和４个面子（顺子或刻子），则判定为胡牌（七对子和国士无双为特殊牌型）。

当将头与面子不重叠时，无论以何种顺序拆分均可判定。但当将头与面子可能重叠时，同一张牌可能同时被视为将头或面子的组成部分。例如，手牌为「１２３３３３４５」时，若将３视为将头，剩余牌可拆分为１２３、３４５作为顺子；但若将３视为刻子，则剩余牌１２３４５无法组成有效的将头。

因此，需遍历所有可能的将头与面子组合进行判定。回溯法通常用于此类组合穷举。

为提高效率，可优先固定将头，再拆分面子。面子的拆分顺序（先取刻子或顺子）需根据役种得分决定。例如，手牌「１１１２２２３３３」可拆分为３个刻子（三暗刻）或３个顺子（一般高），需根据剩余牌型判断哪种拆分得分更高。若剩余牌中包含１或９的将头与顺子时，拆分为顺子可触发更高得分的役种（如平和、纯全带幺九、一般高）。反之，若不符合此类条件，则优先拆分为刻子（如三暗刻）得分更优。因此，当存在多种拆分方式时，需保留所有可能的胡牌候选组合，并根据得分高低最终确定。需要注意的是，刻子与顺子的拆分顺序仅在三暗刻与一般高冲突时需特别处理，无需交替尝试刻子与顺子的拆分模式。 通常只需尝试两种顺序：将头→刻子→顺子、将头→顺子→刻子。

多数情况下，面子组合的重叠较少，回溯次数可控。但清一色等牌型可能导致组合数激增，显著增加处理时间。以下为不同牌型的处理时间测试结果。

【10万次执行】（Java5、Pentium4 3.0GHz）

手牌：１２３５６７一二三五六七西西

回溯法    4297ms

手牌： １１１２３４６７８东东东西西

回溯法    4391ms

手牌：１１１２２２２３３３３４４４

回溯法    4891ms

可见，牌型重叠越多，处理时间越长。

基于索引的方法
-------

该方法通过预先生成所有胡牌牌型并构建索引，仅需索引查询即可完成胡牌判定。
若直接存储所有牌型组合，约需1,700万种模式※以34种牌型（每种用6位表示）为例，14张牌的组合需占用6×14=84bit存储1,700万种组合则至少需要84bit× 1,700万= 1,428,000,000bit≈1.4Gbit≈175MB内存空间。
※ [http://www10.plala.or.jp/rascalhp/mjmath.htm](http://www10.plala.or.jp/rascalhp/mjmath.htm)

尽管现代计算机 内存普遍为1GB级别，直接存储所有牌型组合仍可实现。但若能通过优化显著降低存储需求， 则更符合实际应用需求。

### 连续牌数量索引法

胡牌判定无需区分具体牌种（如万、索），仅需关注数字的连续性及数量。例如：

「１２３」→「１１１」

「５６７」→「１１１」

「１１１」→「３」

「３３３」→「３」

「２３４４５６」→「１１２１１」

将牌型转换为连续数字序列后，用「０」分隔各组并编码为数值。例如：

「１２３５６７一二三五六七西西」→「１１１０１１１０１１１０１１１０２」

「１１１２３４６７８东东东西西」→「３１１１０１１１０３０２」

「１１１２２２２３３３３４４４」→「３４４３」

将数值化的胡牌牌型作为索引存储后，判定时需进行数值比对操作。由于普通计算机为32位架构，若数值在32位以内则更易处理。根据上述规则将手牌数值化后，极端情况下可能生成如下长数值：

「１３５７９一三五七九东南西北」→「１０１０１０１０１０１０１０１０１０１０１０１０１０１」（27段）

由于单种牌最多4张，每段数字用3位表示时需3bit×27段=81bit。直接存储难以作为索引使用。因此，利用“０”不会连续出现的特性，将“０”与前段数字绑定，按以下规则进行比特流编码：

「１」→「０」

「２」→「１１０」

「３」→「１１１１０」

「４」→「１１１１１１０」

「１０」→「１０」

「２０」→「１１１０」

「３０」→「１１１１１０」

「４０」→「１１１１１１１０」

编码时，无论后续数字是否为“０”，均按以下规则转换并附加标识符：若后续为“０”则附加“１０”，否则附加“０”。具体规则为：

「１」→「」

「２」→「１１」

「３」→「１１１１」

「４」→「１１１１１１」

应用上述规则后，示例手牌的编码结果如下：

「１３５７９一三五七九东南西北」

→「１０１０１０１０１０１０１０１０１０１０１０１０１０１」（符号化前）

→「１０１０１０１０１０１０１０１０１０１０１０１０１００」（符号化后）

编码后比特流长度从81位压缩至27位，完全适配32位架构，显著提升索引处理效率。因此，所有胡牌牌型均可按此规则编码并存储为索引。

### 胡牌模式枚举

当手牌以连续牌的数量形式表示时，胡牌形态可根据面子（顺子或刻子）的类型分为以下模式：

「１１１」「１１１」「１１１」「１１１」「２」（全顺子）

「１１１」「１１１」「１１１」「３」「２」（一个刻子）

「１１１」「１１１」「３」「３」「２」（两个刻子）

「１１１」「３」「３」「３」「２」（三个刻子）

「３」「３」「３」「３」「２」（四个刻子）

「２」「２」「２」「２」「２」「２」「２」（七对子）※七对子不需要特殊处理

此外，需考虑副露（碰、吃、杠）情况下的手牌，例如：

「１１１」「１１１」「１１１」「２」（全是顺子、有一个副露）

也要添加上述模式。

每种模式中可能存在牌的重叠，需枚举所有组合。例如全顺子模式包含：

「１１２１１」「１１１」「１１１」「２」

「２２２」「１１１」「１１１」「２」

将牌转换为数量形式时，还需考虑牌的顺序。以下两种牌型会转换为不同数值：

「１１３４５７８９一二三五六七」→「２」「１１１」「１１１」「１１１」「１１１」

「３４５７８９一二三五六七东东」→「１１１」「１１１」「１１１」「１１１」 「２」

通过综合枚举牌的重叠与顺序组合，即可完成索引的构建。

### 确定面子的组成结构

判定是否胡牌仅需通过索引查询即可完成，但要判定役种，则需明确哪些牌构成雀头（将头）、刻子（三张相同牌）或顺子（三张连续牌）。因此，需在编码前的数字序列中记录雀头、刻子及顺子的具体位置，并与索引共同存储。为保留面子（牌组）的组成结构，采用以下位掩码形式构建面子的比特流表示：

低位

3bit    刻子的数量

3bit    顺子的数量

4bit    雀头的位置

4bit    面子的位置

4bit    面子的位置

4bit    面子的位置

4bit    面子的位置

高位

面子的位置将按照刻子→顺子的顺序依次排列。

### 役种的预判

在生成索引时，可通过连续牌的数量序列预判部分役种。例如，以下役种可被提前判定：

「２２２」→一般高

「２２２」「２２２」→两般高

「２」「２」「２」「２」「２」「２」「２」→七对子

「４１１１１１１１１３」→九莲宝灯

「１１１１１１１１１」→一气通贯

除面子（牌组）的构成信息外，可预先判定的役种也将以标志位形式存储在比特流中。

低位

3bit    刻子的数量

3bit    顺子的数量

4bit    雀头的位置

4bit    面子的位置

4bit    面子的位置

4bit    面子的位置

4bit    面子的位置

1bit    七对子flag

1bit    九莲宝灯flag

1bit    一气通贯flag

1bit    两般高flag

1bit    一般高flag

高位

### 生成胡牌的组合模式

根据上述方法，通过穷举所有胡牌组合并进行编码化处理，完成了面子结构的构建与役种预判。为便于数据结构操作，使用Ruby语言生成Java语言适用的HashMap（或TreeMap）代码。经全面统计，胡牌形态的模式总数为9,362种。

将数值化的胡牌形态存入Java的HashMap时，经测算哈希表大小需设为16,384。为此需分配至少32bit×16,384=4byte×16,384=65,536byte≈65KB内存空间。以现代计算机的内存容量而言，此开销完全可接受。若改用TreeMap存储，则无需预先设定哈希表大小。

### 基于索引法的处理速度性能测试

以下展示了使用索引法进行和了（胡牌）判定时的处理速度测试结果。为便于比较，同时列出了常规方法（回溯法）的处理时间。

【10万次执行】（Java5、Pentium4 3.0GHz）

手牌：１２３５６７一二三五六七西西

回溯法    4297ms

索引法(HashMap)      94ms

索引法(TreeMap)      125ms


手牌：１１１２３４６７８東東東西西

回溯法    4391ms

索引法(HashMap)      94ms

索引法(TreeMap)      125ms


手牌：１１１２２２２３３３３４４４

回溯法    4891ms

索引法(HashMap)      94ms

索引法(TreeMap)      94ms


可见，与回溯法相比，判定速度提升了约45至50倍。此外，无论手牌复杂度如何，处理速度均保持稳定。

总结
---

通过使用索引方法进行麻将胡牌判定，我们展示了其高效性。以下是索引法的主要优势：

- 快速判定：大幅提升胡牌判定速度。
- 役种预判：可提前识别部分役种（如一般高、九莲宝灯）。
- 简化逻辑：无需单独处理七对子等特殊牌型。

源代码
---

测试使用以下代码：

*   [回溯法实现](AgariBacktrack.java)
*   [胡牌模式枚举（Ruby程序）](ptn.rb)
*   [索引法实现](AgariIndex.java)

计分小程序
-----

以下小程序使用索引法进行胡牌判定：
[http://hp.vector.co.jp/authors/VA046927/mjscore/](http://hp.vector.co.jp/authors/VA046927/mjscore/)
